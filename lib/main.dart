// üéØ Dart imports:
import 'dart:io';

// üê¶ Flutter imports:
import 'package:flutter/material.dart';

// üì¶ Package imports:
import 'package:file_picker/file_picker.dart';
import 'package:provider/provider.dart';
import 'package:url_launcher/url_launcher.dart';

// üåé Project imports:
import 'package:pdf_indexing/constants.dart';
import 'package:pdf_indexing/functions/db_helper.dart';
import 'package:pdf_indexing/functions/docUtils.dart' as DOCUtils;
import 'package:pdf_indexing/functions/loaded_assets.dart';
import 'package:pdf_indexing/functions/recieve_doc.dart';
import 'package:pdf_indexing/functions/request_permission.dart' as reqP;
import 'package:pdf_indexing/functions/snackbar.dart';
import 'package:pdf_indexing/functions/utils.dart' as Utils;
import 'package:pdf_indexing/model/doc_item_model.dart';
import 'package:pdf_indexing/model/doc_model.dart';
import 'package:pdf_indexing/model/progress_model.dart';
import 'package:pdf_indexing/widgets/action_buttons.dart';
import 'package:pdf_indexing/widgets/search_widget.dart';
import 'package:pdf_indexing/widgets/side_bar_widgets.dart';

void main() {
  runApp(
    /// ‚úÖ Implementation of Provider State Management
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (context) => DOCItemModel()),
        ChangeNotifierProvider(create: (context) => ProgressModel()),
      ],
      child: MaterialApp(
        home: Home(),
      ),
    ),
  );
}

/// üß∞üíÑ [Home] [StatefulWidget]
///
/// Displays Main Layout of the App
///   - Column[
///     SearchWidget,
///     Wrap(items)
///     ]
///   - üîò Floating Action Button
class Home extends StatefulWidget {
  @override
  _HomeState createState() => _HomeState();
}

class _HomeState extends State<Home> {
  /// ‚è≤Ô∏è Current Back Press Time
  ///
  /// During initialization
  ///   - [currBackPressTime] = null
  ///
  /// When üîô Back Pressed its value will change
  DateTime? currBackPressTime;

  /// üôè Bool
  ///
  /// Storage Permission Status
  ///   - true = Granted
  ///   - false = Denied
  ///
  /// set to false at first
  bool storagePermissionStatus = false;

  /// is App is currently importing documents
  ///
  ///   - true = show üåÄ CircularProgressIndicator() on FAB
  ///   - false = show ‚ûï on FAB
  bool isImporting = false;

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: GestureDetector(
        onTap: () {
          // ‚úñÔ∏è Remove Focus from TextField [SearchWidget]
          FocusScopeNode currFocus = FocusScope.of(context);
          if (!currFocus.hasPrimaryFocus && currFocus.hasFocus) {
            FocusManager.instance.primaryFocus!.unfocus();
          }
        },
        child: Scaffold(
          appBar: AppBar(
            title: Text(kAppTitle),
            actions: actionButtons(context: context),
          ),
          drawer: Drawer(
            child: ListView(
              /// TODO: Add Good UI for Side Bar
              padding: EdgeInsets.zero,
              children: [
                SideBarHeader(),
                CheckForUpdateTile(),
              ],
            ),
          ),
          body: WillPopScope(
            // ü§ù Handle üîôüîô Double Back to Exit
            onWillPop: onWillPop,

            // Refresh Indicator, pull down to refresh
            child: RefreshIndicator(
              onRefresh: () async {
                // ‚ûï Update [_items]
                context
                    .read<DOCItemModel>()
                    .updateItem(await Utils.getDOCDataFromDB());
              },
              child: SingleChildScrollView(
                physics: AlwaysScrollableScrollPhysics(),
                child: Column(
                  children: [
                    SearchWidget(),
                    if (storagePermissionStatus)
                      Consumer<DOCItemModel>(
                        builder: (context, docItem, child) {
                          return Wrap(
                            children:
                                (context.read<DOCItemModel>().items.length > 0)
                                    ? context.read<DOCItemModel>().items
                                    : [
                                        Center(
                                          child: Text(kDatabaseEmptyText),
                                        )
                                      ],
                          );
                        },
                      )
                    else
                      Center(
                        child: ElevatedButton(
                          onPressed: () async {
                            requestStoragePermission();
                            updateIsImporting(false);
                          },
                          child: Text(kGivePermissionText),
                        ),
                      ),
                    SizedBox(
                      height: 60,
                    )
                  ],
                ),
              ),
            ),
          ),
          floatingActionButton: FloatingActionButton(
            onPressed: () async {
              // ü§î Checking if Storage permission given or not
              if (storagePermissionStatus) {
                // ü§î Checking if Currently App is Imporing documents files or not
                if (!isImporting) {
                  // updating [isImporting] to 1Ô∏è‚É£ true
                  // showing üåÄ CircularProgressIndicator() on FAB
                  updateIsImporting(true);

                  // List of Filename in the üìÅ App Directory
                  List<String> docFileNameAlreadyInDir =
                      (await Utils.getFilePathListFromDir())
                          .map((path) => Utils.getFileNameFromPath(path))
                          .toList();

                  // üóÑÔ∏è Database Helper
                  DBHelper dbHelper = DBHelper();

                  // üìü [countNewFiles] count new files which are imported
                  // üìü [countExistFiles] count already existing files in üìÅ App Directory
                  // üìü [countCorrupt] count corrupt files which user selected
                  int countNewFiles = 0, countExistFiles = 0, countCorrupt = 0;

                  // [üìÑ], List of All Documents files picked by the user
                  List<File>? docFiles = await DOCUtils.pickDOCFiles();

                  // üìù Setting Default Value of Current & Total
                  // For Progress
                  context.read<ProgressModel>().setDefaultValue();

                  if (docFiles != null) {
                    // üìù Set Total Values = Total No of Files user Selected
                    context
                        .read<ProgressModel>()
                        .updateTotalValue(docFiles.length);

                    // üó®Ô∏è Showing File is Importing Message
                    showSnackBar(context, kImportingFilesMessage);

                    for (File docFile in docFiles) {
                      // ‚ûï Updating the progress of Current Value by 1
                      context.read<ProgressModel>().currentValueIncrement();

                      // ü§î Checking if the [docFile] #Ô∏è‚É£ Already Exist in üóÑÔ∏è Database or not
                      if (await Utils.isHashExists(docFile)) {
                        countExistFiles++;
                        continue;
                      } else {
                        try {
                          // ‚öôÔ∏è Generating [docModel] for [docFile]
                          DOCModel docModel = await DOCUtils.getDOCModelOfFile(
                              docFile, docFileNameAlreadyInDir);
                          // ü§î Checking if the [docModel] is not Null Model
                          if (docModel.path != 'null') {
                            // üì• Saving [docModel] in üóÑÔ∏è Database
                            dbHelper.saveDOC(docModel);
                            countNewFiles++;
                          } else {
                            countCorrupt++;
                          }
                          // ‚ûï Updating [item]
                          context
                              .read<DOCItemModel>()
                              .updateItem(await Utils.getDOCDataFromDB());
                        } catch (e) {
                          print("Error While Importing: ${e.toString()}");
                          countCorrupt++;
                          continue;
                        }
                      }
                    }
                  }
                  // updating [isImporting] to 0Ô∏è‚É£ false
                  // showing ‚ûï on FAB
                  updateIsImporting(false);

                  // üìù Setting Default Value of Current & Total
                  // For Progress to Restart
                  context.read<ProgressModel>().setDefaultValue();

                  // if [countNewFiles] > 0, means some new files is been üì• saved in the üóÑÔ∏è Database
                  if (countNewFiles > 0) {
                    // üî• Deleting Cache
                    Utils.deleteCache();

                    // üó®Ô∏è, Files Imported Successfully SnackBar
                    String text = Utils.getFileOrFilesText(countNewFiles);
                    showSnackBar(context, "$text $kImportedSuccessfully");
                  }

                  // if [countExistFiles] > 0
                  // means some files user selected already exists in the üóÑÔ∏è Databse
                  if (countExistFiles > 0) {
                    // üó®Ô∏è, Files already in the üóÑÔ∏è Database SnackBar
                    String text = Utils.getFileOrFilesText(countExistFiles);
                    showSnackBar(context, "$text $kAlreadyInDB");
                  }
                  // if [countCorrupt] > 0
                  // means some files which user selected are corrupt
                  if (countCorrupt > 0) {
                    // üó®Ô∏è, Files is Corrupt in the üóÑÔ∏è Database SnackBar
                    String text = Utils.getFileOrFilesText(countExistFiles);
                    showSnackBar(context, "$text are Corrupt");
                  }
                } else {
                  // üó®Ô∏è, [isImporting] = 1Ô∏è‚É£ true
                  // showing üåÄ CircularProgressIndicator() on FAB
                  showSnackBar(context, "Files Are Importing, Please Wait");
                }
              } else {
                // üó®Ô∏è, üôè Permission not Granted
                showSnackBar(context, "$kGivePermissionTextFAB");
                requestStoragePermission();
                updateIsImporting(false);
              }
              FilePicker.platform.clearTemporaryFiles();
            },
            child: (isImporting)
                ?
                // üåÄ For Showing CircularProgressIndicator & Percentage
                // To Show The progress of importing files
                // Used üìö [Stack] to show  percentage value inside üåÄ CircularProgressIndicator
                Stack(
                    children: [
                      // Used [SizedBox] to Increase the size of üåÄ CircularProgressIndicator
                      SizedBox(
                        width: 90,
                        height: 90,
                        child: CircularProgressIndicator(
                          color: Colors.white,
                        ),
                      ),
                      Center(
                        child: Consumer<ProgressModel>(
                          // This Shows Percentage of the Progress
                          builder: (context, progressModel, child) {
                            int currValue =
                                context.read<ProgressModel>().currValue;
                            int totalValue =
                                context.read<ProgressModel>().totalValue;
                            return Text(
                                "${((currValue / totalValue) * 100).toInt()}%");
                          },
                          // child: ,
                        ),
                      ),
                    ],
                  )
                :
                // ‚ûï, Currently no file is being imported
                Icon(Icons.add),
          ),
        ),
      ),
    );
  }

  /// ü•á Run Before the [Home]'s [build] method
  @override
  void initState() {
    super.initState();
    Utils.createFolderIfNotExist();
    setstoragePermissionStatus();
    LoadedAssets.load();
    updateSQLDatabase();
    recieveDOC(context: context, updateIsImporting: updateIsImporting);
    checkForUpdateInMain(context);
  }

  /// ü§ù Handles üîôüîô Double Back to Exit
  ///
  /// 2 Second Duration
  Future<bool> onWillPop() {
    DateTime now = DateTime.now();
    if (currBackPressTime == null ||
        now.difference(currBackPressTime!) > Duration(seconds: 2)) {
      currBackPressTime = now;
      showSnackBar(context, "Press once again to exit");
      return Future.value(false);
    } else {
      return Future.value(true);
    }
  }

  /// üôè Requesting Storage Permission
  ///
  /// and sets [storagePermissionStatus]
  ///
  ///   - true = Granted
  ///   - false = Denied
  void requestStoragePermission() async {
    bool permissionStatus = await reqP.requestStoragePermission();
    setState(() {
      storagePermissionStatus = permissionStatus;
    });
  }

  /// üìùüôè
  ///
  /// Set Storage Persmission Status
  ///   - true = Granted
  ///   - false = Denied
  void setstoragePermissionStatus() async {
    bool value = await reqP.getStoragePermissionStatus();
    setState(() {
      storagePermissionStatus = value;
    });
  }

  /// üìù Updating value of [isImporing]
  ///
  ///   - true = üåÄ on FAB
  ///   - false = ‚ûï on FAB
  void updateIsImporting(bool value) {
    setState(() {
      isImporting = value;
    });
  }

  /// ‚ûï‚ôªÔ∏è, Update SQL üóÑÔ∏è Database
  ///
  /// migrating data from old table to new table
  void updateSQLDatabase() async {
    DBHelper dbH = DBHelper();
    await dbH.creatDOCTable();
    List<String> tables = await dbH.getTableNames();
    if (tables.length > 1) {
      String oldTableName =
          tables.where((element) => element != kDOCFilesPath).toList()[0];
      await dbH.cloneTable(srcTable: oldTableName, destTable: kDOCTableName);
      await dbH.dropTable(oldTableName);
      // ‚ûï Update [_items]
      context.read<DOCItemModel>().updateItem(await Utils.getDOCDataFromDB());
    }
  }
}

/// üßê Checing for Update, When App First Opens
Future<void> checkForUpdateInMain(BuildContext context) async {
  // üì•üóûÔ∏è Gets Current App Info in [currAppInfo]
  Map<String, String> currAppInfo = await Utils.getCurrAppInfo();

  // üìù Sets [kNullAppVersionJSON] to [updatedAppInfo], default value if Internet is not available
  var updatedAppInfo = kNullAppVersionJSON;

  // üßê Checking for Internet
  if (await Utils.hasNetwork()) {
    // üì• Gets New App Version Info
    updatedAppInfo = await Utils.getNewAppVersion(info: currAppInfo);
  }

  String newAppVersion = updatedAppInfo['version'].toString();
  
  // üßê Checking if New App Version is Greater than Current App Version
  // - true = if New App Version > Current App Version
  // - false = if New App Version <= Current App Version
  if (newAppVersion.compareTo(currAppInfo["v"] ?? '0.0.0') > 0) {
    String newVersionDownloadUrl = updatedAppInfo['url'];
    showDialog(
        context: context,
        builder: (context) {
          return AlertDialog(
            title: Text("Update Available"),
            content: Text("Version: $newAppVersion \nAvailable To Download"),
            actions: [
              TextButton(
                onPressed: () {
                  Navigator.of(context).pop();
                },
                child: Text("Cancel"),
              ),
              ElevatedButton(
                onPressed: () async {
                  if (await canLaunch(newVersionDownloadUrl)) {
                    await launch(newVersionDownloadUrl);
                  } else {
                    throw "Could Not Lounch $newVersionDownloadUrl";
                  }
                  Navigator.of(context).pop();
                },
                child: Text("Download"),
              ),
            ],
          );
        });
  }
}
